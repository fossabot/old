<template>
    <div class="microphone-button active">
        <div class="active-microphone">
            <IconMeetingMuteAudio v-if="isAudioMute" @click="toggleAudio"/>
            <IconMeetingUnMuteAudio v-else  @click="toggleAudio"/>
            <v-menu>
            <template v-slot:activator="{ props }">
                <v-btn
                    icon="mdi-apple-keyboard-control"
                    color="#474747"
                    size="x-small"
                    v-bind="props"
                ></v-btn>
            </template>
            <v-list>
                <template v-if="!isAudioMute">
                    <v-list-subheader>Microphones</v-list-subheader>
                    <v-list-item
                        v-for="(item, index) in micList"
                        :key="index"
                        :value="index"
                        :active="activeDeviceId == item.deviceId"
                        active-color="primary"
                        @click="onClickMic(item)">
                        <v-list-item-title>{{ item.label }}</v-list-item-title>
                    </v-list-item>
                </template>
                <v-list-subheader>Speakers</v-list-subheader>
                <v-list-item
                    v-for="(item, index) in speakerList"
                    :key="index"
                    :value="index"
                    :active="activeSpeakerId == item.deviceId"
                    active-color="primary"
                    @click="onClickSpeaker(item)">
                    <v-list-item-title>{{ item.label }}</v-list-item-title>
                </v-list-item>
            </v-list>
            </v-menu>
        </div>
    </div>
</template>
<script>
import ZoomController from '../../ZoomController'
import IconMeetingUnMuteAudio from '../Icon/IconMeetingUnMuteAudio.vue'
import IconMeetingMuteAudio from '../Icon/IconMeetingMuteAudio.vue'
import {MutedSource, AudioChangeAction } from '@zoom/videosdk';
export default {
    components: {IconMeetingUnMuteAudio, IconMeetingMuteAudio},
    data(){
        return {
            isAudioMute: true,
            selectMic: null,
            activeDeviceId: null,
            audioType: '',
            micList: [],
            selectSpeaker: null,
            activeSpeakerId: null,
            speakerList: [],
            muteShareAudioByUser: false
        }
    },
    watch:{
        selectMic(val){
            if(val){
                this.switchMic(val.deviceId)
            }
        },
        isAudioMute(val){
            if(val === false){
                this.micList = ZoomController.zoomClient.getMediaStream().getMicList()
            }
        }
    },
    mounted(){
        ZoomController.zoomClient.on('current-audio-change', this.onHostAudioMuted);
        this.emitter.on("onMuteShareScreenAudio",(e)=>{
            this.muteShareAudioByUser = e.muteShareAudioByUser
        })
    },
    unmounted(){
        ZoomController.zoomClient.off('current-audio-change', this.onHostAudioMuted);
    },
    methods:{
        async toggleAudio(){
            await ZoomController.toggleAudio(this.muteShareAudioByUser);
            this.activeDeviceId = ZoomController.zoomClient.getMediaStream().getActiveMicrophone()
        },
        async switchMic(deviceId){
            await ZoomController.zoomClient.getMediaStream().switchMicrophone(deviceId)
            this.activeDeviceId = deviceId
        },
        async onHostAudioMuted(payload){
            try {
                const { action, source, type } = payload;
                if (action === AudioChangeAction.Join) {
                    this.isAudioMute = await ZoomController.zoomClient.getMediaStream().isAudioMuted()
                    this.audioType = type;
                } else if (action === AudioChangeAction.Leave) {
                    this.isAudioMute = true;
                } else if (action === AudioChangeAction.Muted) {
                    this.isAudioMute = true;
                    if (source === MutedSource.PassiveByMuteOne) {
                        //message.info('Host muted you');
                    }
                } else if (action === AudioChangeAction.Unmuted) {
                    this.isAudioMute = false;
                    if (source === 'passive') {
                        //message.info('Host unmuted you');
                    }
                }
                this.speakerList = ZoomController.zoomClient.getMediaStream().getSpeakerList()
                this.activeSpeakerId = ZoomController.zoomClient.getMediaStream().getActiveSpeaker()
                this.activeDeviceId = ZoomController.zoomClient.getMediaStream().getActiveMicrophone()
            } catch (error) {
                console.log("onHostAudioMuted", error)
            }
        },
        onClickMic(val){
            this.selectMic = val
        },
        onClickSpeaker(val){
            if(val){
                this.switchSpeaker(val.deviceId)
            }
        },
        async switchSpeaker(id){
            await ZoomController.zoomClient.getMediaStream().switchSpeaker(id)
            this.activeSpeakerId = id
        }
    }
}
</script>

<style lang="scss" scoped>
.microphone-button{
    width: 44px;
    transition: width 0.3s ease;
    &.active{
        width: 100px;
    }
    .active-microphone{
        width: 100px;
        background: rgba(225, 225, 225, 0.15);
        border-radius: 15px;
        display: flex;
        justify-content: space-between;
        align-items: center;
        padding-right: 10px;
    }
}
</style>